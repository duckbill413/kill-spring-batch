# Spring Batch Listener 와 활용

## JobExecutionListener

- Job 실행의 시작과 종료 시점에 호출되는 리스너 인터페이스다.
- Job 실행 결과를 이메일로 전송하거나, Job 이 시작하기 전에 필요한 리소스를 준비하고 끝난 후에 정리하는 부가 작업을 수행

**afterJob()** 메서드는 잡 실행 정보가 메타데이터 저장소에 저장되기 전에 호출된다.  
이를 활용하면 특정 조건에 따라 Job 의 실행 결과 상태를 완료(`COMPLETED`) 에서 실패 (`FAILED`)로 변경하는 것도 가능하다.

```java
public interface JobExecutionListener {
  default void beforeJob(JobExecution jobExecution);

  default void afterJob(JobExecution jobExecution);
}
```

## StepExecutionListener

- Step 실행과 종료시점에 호출되는 리스너 인터페이스

```java
public interface StepExecutionListener extends StepListener {
  default void beforeStep(StepExecution stepExecution) {
  }

  @Nullable
  default ExitStatus afterStep(StepExecution stepExecution) {
    return null;
  }
}
```

- `afterStep` 메서드를 보면 ExitStatus 를 반환하는 것을 알 수 있는데, 이를 통해 afterStep() 에서 특정 조건에 따라 Step 의 실행 결과 상태를 직접 변경할 수 있다.

## ChunkListener

- ChunkListener 는 하나의 청크 단위 처리가 시작되기 전, 완료된 후, 그리고 에러가 발생했을 때 호출되는 리스너 인터페이스

```java
public interface ChunkListener extends StepListener {
  default void beforeChunk(ChunkContext context) {
  }

  default void afterChunk(ChunkContext context) {
  }

  default void afterChunkError(ChunkContext context) {
  }
}
```

- `afterChunk` 는 트랜잭션이 커밋된 후에 호출된다.
- 반면 청크 처리 도중 예외가 발생하는 경우 `afterChunkError` 가 호출되는데, 이는 청크 트랜잭션이 **롤백**된 이후에 호출된다.

## Item[Read|Process|Write]Listener

- Item[Read|Process|Write]Listener 는 아이템의 읽기/처리/쓰기 작업이 수행되는 시점에 호출되는 리스너 인터페이스 이다.
- 아이템 단위의 처리 전후와 에러 발생 시점에 호출된다.

```java
// ItemReadListener.java
public interface ItemReadListener<T> extends StepListener {
  default void beforeRead() {
  }

  default void afterRead(T item) {
  }

  default void onReadError(Exception ex) {
  }
}

// ItemProcessListener.java
public interface ItemProcessListener<T, S> extends StepListener {
  default void beforeProcess(T item) {
  }

  default void afterProcess(T item, @Nullable S result) {
  }

  default void onProcessError(T item, Exception e) {
  }
}

// ItemWriteListener.java
public interface ItemWriteListener<S> extends StepListener {
  default void beforeWrite(Chunk<? extends S> items) {
  }

  default void afterWrite(Chunk<? extends S> items) {
  }

  default void onWriteError(Exception exception, Chunk<? extends S> items) {
  }
}
```

- `ItemReadListener.afterRead()` 는 ItemReader.read() 호출 후에 호출되지만, ItemReader.read() 메서드가 더 이상 읽을 데이터가 없어 `null` 을 반환할 때는
  호출되지 않는다.
- 반면, `ItemProcessListener.afterProcess()` 는 ItemProcessor.process() 메서드가 `null` 을 반환하더라도 호출된다. 참고로 ItemProcessor 에서
  `null` 을 반환하는 것을 해당 데이터를 필터링하겠다는 의미
- `ItemWriteListener.afterWrite()` 는 트랜잭션이 커밋되기 전, 그리고 ChunkListener.afterChunk() 가 호출되기 전에 호출된다.

![img.png](../../../../../../../../assets/images/ItemListener1.png)

> **배치 리스너**, 이런 것들을 할 수 있다.
> - **단계별 모니터링과 추적**: 배치 작업의 모든 단계를 내 손아귀에 넣을 수 있다. 각 Job과 Step의 실행 전후에 로그를 남길 수 있다. Step 이 언제 시작하고, 언제 끝났는지, 몇 개의 데이터를
    처리했는지도 모든 것을 기록하고 추적할 수 있다.
> - **실행 결과에 따른 후속 처리**: Job과 Step의 실행 상태를 리스너에서 직접확인하고 조치를 할 수 있다. JobExecutionListener 의 afterJob() 메서드에서 Job의 종료 상태를
    확인하고 후속 조치를 취할 수 있다.
> - **데이터 가공과 전달**: 실제 처리 로직 전후에 데이터를 추가하고 정제하거나 변환할 수 있다. StepExecutionListener 나 ChunkListener 를 사용하면 ExecutionContext
    의 데이터를 수정하거나 필요한 정보를 추가할 수 있다. 이를 통해 Step 간에 데이터를 전달하거나, 다음 처리에 필요한 정보를 미리 준비할 수 있다.
> - **부가 기능 분리**: 주요 처리 로직과 부가 로직을 깔끔하게 분리할 수 있다. 가령 ChunkListener 에서 오류가 발생한 경우 afterChunkError() 메서드에서 관리자에게 알림 메일을
    보내는 등의 부가적인 일을 처리할 수 있다.

## JobExecutionListener 와 ExecutionContext 를 활용한 동적 데이터 전달

- 잡 파라미터 만으로는 전달할 수 없는 동적 데이터가 필요한 경우
- `JobExecutionListener` 의 `beforeJob()` 메서드를 활용하면 추가적인 동적 데이터를 각 Step 에 전달할 수 있다.
- [AdvancedSystemInfiltrationConfig](./AdvancedSystemInfiltrationConfig.java)
- [InfiltrationPlanListener](./InfiltrationPlanListener.java)


- 예제 실행

```shell
./gradlew bootRun --args='--spring.batch.job.name=systemInfiltrationJob'
```

### 왜 JobParameters 가 아닌 ExecutionContext 를 사용할까?

한 번 생성된 JobParameters 는 변경할 수 없기 때문이다.

- Spring Batch 의 핵심 철학 중 하나는 배치 작업의 **재현 가능성(Repeatability)**과 **일관성(Consistency)**를 보장하는 것
- 이를 위하여 **JobParameters** 는 불변(immutable) 하게 설계되었다.
  - **재현 가능성**: 동일한 JobParameters 로 실행한 Job 은 항상 동일한 결과를 생성한다. 실행 중간에 JobParameters 가 변경되면 이를 보장할 수 없다.
  - **추적 가능성**: 배치 작업의 실행 기록(JobInstance, JobExecution) 과 JobParameters 는 메타데이터 저장소에 저장된다. JobParameters 기록과 실제 작업의 불일치가
    발생할 수 있다.

> [시스템 경고]  
> JobExecutionListener 와 ExecutionContext 를 사용해 데이터를 동적으로 전달하는 방식은 분명 유용할 수 있지만,  
> JobParameters 만으로 충분히 처리할 수 있는 경우에도, 이 방법을 사용하고 싶은 유혹에 빠지기 쉽다.
>
> **잘못된 코드, 이렇게 작성하지 마라💀**
> ```java
> // 이런 코드에 현혹되지 마라
> @Override
> public void beforeJob(JobExecution jobExecution) {
>   jobExecution.getExecutionContext()
>       .put("targetDate", LocalDate.now()); // 치명적인 실수다
> }
> ```
> 이 방식의 문제점은 무엇일까?
> - 어제 데이터를 다시 처리하고 싶으면? 불가능하다. 프로그램을 수정하지 않으면 그날의 데이터를 다시 처리할 수 없다.
>
> 결국 하드코딩된 방식은 배치의 유연성을 떨어뜨리고, 필요한 순간에 원하는 데이터를 처리할 수 없게 만든다.
>
> 대신 이렇게 하라💀  
> **외부에서 파라미터로 받아라**
> ```shell
> ./gradlew bootRun --args='--spring.batch.job.name=systemInfiltrationJob -date=2024-10-13'
> ```
> 이렇게 외부에서 날짜 값을 전달받으면, 배치 작업의 유연성을 극대화할 수 있다. JobParameters는 대부분의 데이터를 외부에서 받을 수 있는 훌륭한 방법이다.
>
> JobParameters를 사용할 수 있다면 그 방법을 사용하라. 외부에서 값을 받는 것이 훨씬 더 안전하고 유연하다. JobExecutionListener와 ExecutionContext는 외부에서 값을 받을
> 수 없는 경우에만 사용하자.

- Step 수준 ExecutionContext 에 저장된 데이터는 해당 Step 에서만 접근 가능하므로 다른 Step 과 공유가 불가능하다.
- 그래서 한 Step 의 ExecutionContext 에 존재하는 데이터를 다음 Step 에게 전달하려면 Step 의 ExecutionContext 의 값을 가져와 이를 Job 수준 ExecutionContext
  에 직접 설정해주어야 한다.
- **다음과 같은 형태**
  ```java
  StepExecution stepExecution = contribution.getStepExecution();
  ExecutionContext stepExecutionContext = stepExecution.getExecutionContext();
  Integer infiltrationCount = (Integer) stepExecutionContext.get("infiltrationCount");
  
  JobExecution jobExecution = stepExecution.getJobExecution();
  jobExecution.getExecutionContext.put("totalInfiltrations",infiltrationCount);
  ```
- Spring Batch 는 이런 반복적인 불편한 과정을 알아서 처리해줄 수 있도록 `ExecutionContextPromotionListener` 라는 StepExecutionListener 구현체를 제공한다.
- `ExecutionContextPromotionListener` 를 사용하면 위와 같이 번거로운 작업이 없이도 손쉽게 스텝 간 데이터 공유가 가능하다

## ExecutionContextPromotionListener 를 활용한 Step 간 데이터 공유

`ExecutionContextPromotionListener` 는 `Step` 수준 `ExecutionContext` 의 데이터를 `Job` 수준 `ExecutionContext` 로 등록시켜주는
`StepExecutionListener` 의 구현체이다.

> Spring Batch 에서는 Step 수준의 ExecutionContext 데이터를 Job 수준의 ExecutionContext 로 옮기는 과정을 승격(Promote) 이라 부른다.
> 이 리스너는 StepExecutionListener 의 afterStep() 메서드를 오버라이드하여 승격 작업을 수행한다.

```java
import org.springframework.batch.core.listener.ExecutionContextPromotionListener;
import org.springframework.context.annotation.Bean;

@Bean
public ExecutionContextPromotionListener promotionListener() {
  ExecutionContextPromotionListener listener = new ExecutionContextPromotionListener();
  listener.setKeys(new String[]{"targetSystem"});
  return listener;
}
```

1. 먼저 `ExecutionContextPromotionListener` 에는 Step 수준의 ExecutionContext 에서 Job 수준으로 승격할 데이터의 **Key** 값을 지정해주어야 한다. 이는
   `setKeys()` 메서드를 통해 설정할 수 있다.
2. 이렇게 생성한 `promotionListener` 를 Step 의 리스너로 등록한다.
3. 이렇게하면 Step 수준의 ExecutionContext 데이터가 Job 수준의 ExecutionContext 로 승격되어, 다음 스텝에서 조회할 수 있다.
    ```java
    @StepScope
    public Tasklet eliminationTasklet(
        // Job의 ExecutionContext에서 값 조회
        @Value("#{jobExecutionContext['targetSystem']}") String target
    ) {
      return (contribution, chunkContext) -> {
        log.info("시스템 제거 작업 실행: {}", target);
        return RepeatStatus.FINISHED;
      };
    }
    ```

## Listener 와 @JobScope, @StepScope 통합

- 리스너와 Spring Batch Scope 를 통합하면 리스너에서 잡 파라미터를 매우 쉽게 다룰 수 있다.
- 이를 통해 실행 시점에 결정되는 값들을 리스너내에서도 활용할 수 있다는 말이다.
- [SystemDestructionConfig_3](SystemDestructionConfig_3.java)

---

## Listener 마지막 훈련: 성능과 모범 사례

**리스너를 효과적으로 다루는 법**

1. 무기 선택의 정확성

- `JobExecutionListener`: 전체 작전의 시작과 종료를 통제
- `StepExecutionListener`: 각 작전 단계의 실행을 감시
- `ChunkListener`: 시스템을 청크단위로 제거할 때, 반복의 시작과 종료 시점을 통제
- `Item[Read|Process|Write]Listener`: 개별 아이템 식별 통제

2. 예외 처리는 신중하게  
   `JobExecutionListener` 의 `beforeJob()`과 StepExecutionListener의 `beforeStep()` 에서 예외가 발생하면 Job 과 Step 이 실패한 것으로
   판단된다.  
   하지만 모든 예외가 Step 을 중단시켜야 할 만큼 치명적인 것은 아니다. 이런 경우는 직접 예외를 잡아서 무시하고 진행하는 것이 현명하다.
   > ☠️ [시스템 인텔리전스]  
   > 반면, `JobExecutionListener.afterJob()`과 `StepExecutionListener.afterStep()`에서 발생한 예외는 무시된다.  
   > 즉, 예외가 발생해도 Job과 Step 의 실행 결과에는 영향을 미치진 않는다.

    ```java
    @Override
    public void beforeStep(StepExecution stepExecution) {
      try {
        // 치명적인 로직 수행
        systemMetricCollctor.collect();
      } catch (Exception e) {
        // 심각하지 않은 예외는 로그만 남기고 진행
        log.warn("메트릭 수집 실패. 작전은 계속 진행: {}", e.getMessage());
        // 정말 심각한 문제면 예외를 던져서 Step 을 중단시킨다.
        // throw new RuntimeException("치명적 오류 발생", e);
      }
    }
    ```

3. 단일 책임 원칙 준수

- 리스너는 감시와 통제만 담당한다.
- 실제 시스템 제거 로직(비즈니스 로직)은 분리하라
- 리스너가 너무 많은 일을 하면 유지보수가 어려워지고 시스템 동작을 파악하기 힘들다.

---

## 성능 최적화를 위한 경고

1. 실행 빈도를 고려하라

- `JobExecutionListener`/`StepExecutionListener`
  - Job, Step 실행당 한 번씩만 실행되므로 비교적 안전하다.
  - 무거운 로직이 들어가도 전체 성능에 큰 영향 없음
- `ItemReadListener`/`ItemProcessListener`
  - 매 아이템마다 실행되므로 치명적일 수 있다.

  ```java
  // 이런식의 코드는 시스템을 마비시킬 수 있음
  @Override
  public void afterRead(Object item) {
    heavyOperation(); // 매 아이템마다 실행되면 시스템이 마비됨
    removeApiCall(); // 외부 API 호출은 더더욱 위험
  }
  ```

2. 리소스 사용을 최소화하라

- 데이터베이스 연결, 파일 I/O, 외부 API 호출은 최소화
- 리스너 내 로직은 가능한 가볍게 유지
- 특히 Item 단위 리스너에서는 더욱 중요